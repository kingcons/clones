* Clones Tasks
*** Implement ROM parsing, returning a plist
**** DONE Function parse-rom (pathname) -> plist of attributes
**** DONE Add pathname as an attribute in parse-rom output
**** DONE Finish tests for parse-rom
**** DONE Write docs for exported symbols in ROM module
*** Implement mapper class, then nrom support
**** DONE mapper interface -> get-prg, set-prg, get-chr, set-chr, load-rom
**** DONE add nice docs for mapper module
**** add a pretty printer for mappers?
*** Implement Disassembler
**** DONE Add a nice instruction reference
**** DONE Add a simple memory interface fetch/store, just RAM and mapper for now, 0s if doing other I/O
**** DONE Write tests for the memory interface
**** DONE Add opcode-data
**** DONE Build opcode table from instruction-data. Can this be shared with CPU? array of opcode structs
***** Opcodes: name, access pattern, code, bytes, cycles, addressing mode. Skip docs?
***** Access pattern: static/jump/read/write/rmw
**** DONE Build disassembler skipping arg formatting, just hex bytes
*** Stream Warmup
**** DONE Fix unbound pathname in default mapper / nestest
**** DONE Convert uses of initform to default-initargs
**** DONE Build out a correct arg formatter for the different addressing modes. Maybe use trivia/defunion?
**** DONE Measure build-opcode-table consing. Export *opcode-table* var instead of rebuilding on demand
**** TODO Write tests for the disassembler. Adding a stream keyarg would help.
*** Implement CPU
**** DONE Add conditions for addressing-mode-not-implemented, opcode-not-implemented, opcode-not-found
**** DONE Add a CPU structure with correct default values and slots
**** DONE Add a nestest harness in clones.test.cpu
**** DONE Add a function single-step(cpu) that dispatches to an appropriate handler for the opcode
**** DONE Opcode Boss Rush!
***** Start by going over the diff from last time, big thing was added explicit errors to make the fix clear
****** https://git.sr.ht/~kingcons/clones/commit/dd3cadaf94a56bbfecd6d7cec5977e6719ddb715
***** Worth calling out that both keywords as function names and structures are antipatterns
****** https://www.reddit.com/r/lisp/comments/4tihvq/keywords_as_function_names/
****** Structs is a bit of a premature optimization but why use classes for something that isn't polymorphic?
***** Keep notes on any weird / tricky things to implement we encounter (rmw, page boundary bonus cycle, etc)
**** TODO Opcode Boss Rush Pt. 2!
***** Does it make a difference to use ASH/+ to combine bytes into an address, or would DPB be any better?
***** What is the best way to set arbitrary bits in the status register?
****** What's the difference between DPB and DEPOSIT-FIELD?
**** TODO Rewrite SET-FLAG-ZN to not hurt my soul.
**** TODO Maybe extract STACK-PUSH-WORD out from JSR if we need it again?
**** TODO Fix the horrific docs for *opcode-table* and/or structure constructors like make-cpu?
**** TODO Add support for working with status register in terms of status keywords like :interrupt :carry etc

* External dependencies
** DONE Add support for sourcehut URIs to mgl-pax?

* Weird issues
** Hit a confusing disassembler bug because of a missing ' after the , in a format string. Eg. ~2,'0X
** Stack grows downward on the 6502 lol (encountered during :JSR) ðŸ™ƒ
*** Hit this _TWICE_ also. Following stack discipline by hand sucks, added STACK-PUSH-WORD, STACK-POP-WORD.
*** This was extra confusing because we ran into the issues while in RTS not during the JSR.
*** The return address was getting mangled and it took adding explicit byte printouts on both sides to fix.
** Relative instruction cycle counting is weird and based on if you cross a page to get to new PC
*** Hit this _TWICE_ which was even more confusing. TL;DR: You don't pay the toll unless you take the branch!
** PLA was super confusing because bit 5 became unset and never should be unset.
*** Even more confusing, the 6502 doc I have says it should never be unset but nestest log says otherwise.
